from pysmt.shortcuts import Symbol, And, Plus, Int, ExactlyOne, Equals, get_formula_size, LE, Or, Not, Real, GE
from pysmt.shortcuts import Solver
from pysmt.typing import INT, REAL
import random
import json
import time
import subprocess
import typing
import requests
from requests.auth import HTTPBasicAuth
from placementCycle.placement import create_objective, microservice, availability


def find_topology(nodes):
    """
    Find the current topology size
    :param nodes: the list of available nodes
    :return: a dictionary to save the failure probabilities of each node
    """
    nodes_failures_probs = {}
    for node in nodes:
        nodes_failures_probs[str(node['id'])] = float(node['failure'])

    return nodes_failures_probs


def find_latency(node_ip: str):
    """
    Get the average latency of a node
    :param node_ip: the ip address of a node
    :return: the average latency to communicate with the node, considering 10 pings
    """
    results = subprocess.run(['ping', '-c', '10', node_ip], stdout=subprocess.PIPE).stdout.decode('utf-8')

    return results.split('\n')[-2].split(' = ')[1].split('/')[1]


def build_latency_dict(nodes, credentials):
    """
    :param nodes: the list of nodes
    :return: a dictionary containing the latencies between two nodes, where key is a string showing the
    communication link between two nodes, while the value represents the communication latency between them.
    """
    latencies = {}
    nodes_latencies = {}
    print(f'List of nodes: {nodes}')

    print(f'Send the topology to all nodes and get the latency')
    for node in nodes:
        resp_nodes = requests.post(node['ip'] + '/nodes', json=nodes, auth=credentials, timeout=100)
        print(resp_nodes.status_code)
        resp_latency = requests.get(node['ip'] + '/get_latency', auth=credentials, timeout=500)
        latencies[node['id']] = resp_latency.json()

    for src_id, latency_dict in latencies.items():
        for dest_id, latency in latency_dict.items():
            s = f'{src_id}-{dest_id}'
            nodes_latencies[s] = int(float(latency))

    return nodes_latencies


def get_latency(n1, n2, latency_dict):
    """
    :param n1: the source, where a microservice is placed.
    :param n2: the destination, where a microservice is placed.
    :param latency_dict:  a dictionary containing the latency between dependent microservices
    :return: the latency between the two nodes.
    """
    print(f'The latency dict is: {latency_dict}')
    s = f'{n1}-{n2}'
    print(f'Looking for the following group: {s}')
    if s in latency_dict:
        latency = latency_dict[s]
    return latency


def get_deployment_solution(file_name):
    """
    Read the deployment solution generated by the deployment strategy and create a JSON file with all valid solutions
    :param file_name: the name of the deployment input file
    :return: the JSON file name
    """
    deployment_strategy = {}
    deployment_solutions = []
    #find the size of the application
    _, _, app_size = file_name.split('_')

    # read the input file and filter the valid solutions
    with open('../results/deployment/' + file_name + '.txt', 'r') as file:
        solution = {}
        for line in file.readlines():
            if line.startswith('test'):
                _, id = line.rstrip('\r\n').split(' = ')
                solution['id'] = id
            if line.startswith('m'):
                tsk, location = line.rstrip('\r\n').split(' = ')
                if location == '[]':
                    continue
                solution[tsk] = location
            if line.startswith('>>>>') and solution:
                if len(solution) == int(app_size[8:]) + 1:
                    deployment_solutions.append(solution)
                solution = {}
    deployment_strategy['deployment_strategies'] = deployment_solutions

    with open('../results/deployment/' + file_name + '_valid_solutions.json', 'w') as json_file:
        json.dump(deployment_strategy, json_file)

    return '../results/deployment/' + file_name + '_valid_solutions.json'


def latency(m1, m2):
    """
    :param m1: a symbol of a microservice.
    :param m2: a symbol of a microservice.
    :return: return a SMT symbol for latency between two nodes.
    """
    return Symbol("l_%s_%s" % (m1, m2), INT)


def create_latency_constraint(app):
    """
    :param app: the job model graph.
    :return: a list of latency encodings constraint, the latency objective, a list of dependencies between microservices,
     and a list of microservices.
    """
    problem = []
    dependencies = []
    microservices = []
    for m1 in app["IoTapplication"]["microservices"]:
        microservices.append(microservice(str(m1["id"])))
        for d in m1["dest"]:
            depend_microservices = []
            problem.append(latency(str(m1["id"]), str(d["id"])))
            depend_microservices.append(str(m1["id"]))
            depend_microservices.append(str(d["id"]))
            dependencies.append(depend_microservices)
    return LE(Plus(problem), Int(int(app["IoTapplication"]["SLA"]['e2e']))), problem, dependencies, microservices


def create_microservice_facts(dependencies, microservices_on_nodes, latency_dict):
    """
    :param dependencies:
    :param microservices_on_nodes: a dictionary containing a solution where key is a microservice and value
    is a list of nodes
    :param latency_dict:  a dictionary containing the latency between dependent microservices
    :return: a SMT encoding containing the latency between two microservices.
    """
    microservice_facts = []
    for grp in dependencies:
        if grp[0] in microservices_on_nodes and grp[1] in microservices_on_nodes:
            for n1 in microservices_on_nodes[grp[0]]:
                for n2 in microservices_on_nodes[grp[1]]:
                    microservice_facts.append(And(Equals(microservice(grp[0]), Int(int(n1))), Equals(microservice(grp[1]),
                                    Int(int(n2)))).Implies(Equals(latency(grp[0], grp[1]),
                                                                  Int(get_latency(n1, n2, latency_dict)))))
    return And(microservice_facts)


def create_microservices_possibilities(microservices_on_nodes):
    """
    :return: a SMT encoding containing all microservice mapping possibilities.
    """
    microservices_possibilities = []
    for m, nodes in microservices_on_nodes.items():
        microservices_possibilities.append(Or(Equals(microservice(m), Int(int(n))) for n in nodes))
    return And(microservices_possibilities)


def find_microservices_on_nodes(deployment_solution):
    """
    Convert the JSON dict values from string to list
    :param deployment_solution: the deployment solution taken from the deployment JSON file
    :return: a new dictionary containing a solution where key is a microservice and value is a list of nodes
    """
    microservices_on_nodes = {}
    for m, nodes in deployment_solution.items():
        microservices_on_nodes[str(m)] = [str(elem) for elem in nodes]

    return microservices_on_nodes


def microservice_availability_encoding(microservices_on_nodes, nodes_failures):
    """
    :param microservices_on_nodes: a dictionary containing the location of every microservices
    :param nodes_failures: a dictionary where the failure rate of all nodes is stored
    :return: an encoding for discovering the availability of a microservice based on its allocation
    """
    encoding = list()
    avail_obj = list()
    for m, nodes in microservices_on_nodes.items():
        avail_obj.append(availability(m))
        for n in nodes:
            encoding.append(Equals(microservice(m), Int(int(n))).Implies(Equals(availability(m),
                                                                                Real(float(1 - nodes_failures[n])))))
    return And(encoding), avail_obj


# A context (with-statment) lets python take care of creating and
# destroying the solver.
def self_adapt(solution, nodes, application, credentials):

    nodes_failures = find_topology(nodes)
    latency_dict = build_latency_dict(nodes, credentials)

    #create the three encodings for the SMT formula
    problem, latencies, dependencies, microservices = create_latency_constraint(application)

    start_time = millis()
    print(f'Starting to find an invocation chain...')
    microservices_on_nodes = find_microservices_on_nodes(solution)
    microservice_facts = create_microservice_facts(dependencies, microservices_on_nodes, latency_dict)
    microservice_possibilities = create_microservices_possibilities(microservices_on_nodes)
    availability_enc, avail_obj = microservice_availability_encoding(microservices_on_nodes, nodes_failures)
    problem_availability = create_objective(avail_obj, application["IoTapplication"]["SLA"]['availability'])

    # combine the encoding above to generate the SMT formula
    f1 = microservice_possibilities.And(microservice_facts)
    f2 = f1.And(availability_enc)
    f3 = f2.And(problem_availability)
    formula = f3.And(problem)

    invocation_path = dict()

    with Solver() as solver:
        solver.add_assertion(formula)
        if solver.solve():
            for m in microservices:
                print(f'{m} = {solver.get_value(m)}')
                invocation_path[str(m)] = str(solver.get_value(m))
            for l in latencies:
                print(f'{l} = {solver.get_value(l)}')
        else:
            print("No solution found")
    print(f'time =  {millis() - start_time} ms')
    return invocation_path


def millis():
    return int(round(time.time() * 1000))
